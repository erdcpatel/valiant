"""
Template Engine - Core infrastructure for workflow template generation

This module provides the foundation for creating intelligent workflow templates
that generate code based on user inputs and best practices.
"""

from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
import os
import re
from pathlib import Path
from enum import Enum
import os
import re
from pathlib import Path


@dataclass
class TemplateInfo:
    """Information about an available template"""
    name: str
    description: str
    category: str


class QuestionType(Enum):
    """Types of questions for template configuration"""
    TEXT = "text"
    SELECT = "select"
    MULTISELECT = "multiselect"
    BOOLEAN = "boolean"
    NUMBER = "number"
    EMAIL = "email"
    PATH = "path"


@dataclass
class TemplateQuestion:
    """A configuration question for workflow generation"""
    id: str
    question: str
    type: QuestionType
    required: bool = True
    default: Any = None
    options: Optional[List[str]] = None
    help_text: Optional[str] = None
    validation: Optional[Callable[[Any], bool]] = None
    
    def validate_answer(self, answer: Any) -> bool:
        """Validate an answer against this question's constraints"""
        if self.required and (answer is None or answer == ""):
            return False
        
        if self.validation:
            return self.validation(answer)
        
        if self.type == QuestionType.SELECT and self.options:
            return answer in self.options
        
        if self.type == QuestionType.MULTISELECT and self.options:
            if isinstance(answer, list):
                return all(item in self.options for item in answer)
            return False
        
        return True


@dataclass  
class GeneratedFile:
    """Represents a file generated by a template"""
    path: str
    content: str
    file_type: str  # "workflow", "test", "doc", "config"
    executable: bool = False


class WorkflowTemplate:
    """Base class for workflow templates"""
    
    def __init__(self, name: str, description: str, category: str = "general"):
        self.name = name
        self.description = description
        self.category = category
        self.questions: List[TemplateQuestion] = []
        self._setup_questions()
    
    def _setup_questions(self):
        """Override this method to define template-specific questions"""
        pass
    
    def add_question(self, id: str, question: str, type: QuestionType, **kwargs):
        """Add a configuration question to the template"""
        q = TemplateQuestion(
            id=id,
            question=question,
            type=type,
            **kwargs
        )
        self.questions.append(q)
        return q
    
    def validate_answers(self, answers: Dict[str, Any]) -> List[str]:
        """Validate all answers and return error messages"""
        errors = []
        for question in self.questions:
            answer = answers.get(question.id)
            if not question.validate_answer(answer):
                errors.append(f"{question.question}: Invalid or missing answer")
        return errors
    
    def generate(self, answers: Dict[str, Any]) -> List[GeneratedFile]:
        """Generate workflow files based on answers"""
        errors = self.validate_answers(answers)
        if errors:
            raise ValueError(f"Invalid answers: {'; '.join(errors)}")
        
        return self._generate_files(answers)
    
    def _generate_files(self, answers: Dict[str, Any]) -> List[GeneratedFile]:
        """Override this method to implement file generation logic"""
        raise NotImplementedError("Templates must implement _generate_files")
    
    def _sanitize_name(self, name: str) -> str:
        """Convert name to valid Python identifier"""
        # Remove special characters and convert to snake_case
        sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name.lower())
        sanitized = re.sub(r'_+', '_', sanitized)  # Remove multiple underscores
        sanitized = sanitized.strip('_')  # Remove leading/trailing underscores
        
        # Ensure it doesn't start with a number
        if sanitized and sanitized[0].isdigit():
            sanitized = f"workflow_{sanitized}"
        
        return sanitized or "workflow"
    
    def _render_template(self, template: str, context: Dict[str, Any]) -> str:
        """Simple template rendering with variable substitution"""
        result = template
        for key, value in context.items():
            placeholder = f"{{{{{key}}}}}"
            result = result.replace(placeholder, str(value))
        return result


class TemplateEngine:
    """Main engine for managing and executing workflow templates"""
    
    def __init__(self):
        self.templates: Dict[str, WorkflowTemplate] = {}
        self._register_builtin_templates()
    
    def _register_builtin_templates(self):
        """Register built-in templates"""
        # Import here to avoid circular imports
        try:
            from .api_db_template import ApiDbTemplate
            self.register_template(ApiDbTemplate())
        except ImportError:
            pass  # Template not available yet
    
    def register_template(self, template: WorkflowTemplate):
        """Register a new template"""
        self.templates[template.name] = template
    
    def list_templates(self) -> List[TemplateInfo]:
        """List all available templates"""
        templates = []
        
        # Import and register available templates
        try:
            from .api_db_template import ApiDbTemplate
            api_db = ApiDbTemplate()
            templates.append(TemplateInfo(
                name=api_db.name,
                description=api_db.description,
                category=api_db.category
            ))
        except ImportError:
            pass
        
        return templates
    
    def generate_workflow(self, template_name: str, output_path: str, interactive: bool = True) -> List[GeneratedFile]:
        """Generate workflow files from a template"""
        # Find the template
        template = None
        if template_name == "api_db_integration":
            from .api_db_template import ApiDbTemplate
            template = ApiDbTemplate()
        
        if not template:
            raise ValueError(f"Template '{template_name}' not found")
        
        # Get user answers
        answers = {}
        if interactive:
            # Interactive mode - prompt for each question
            for question in template.questions:
                answer = self._prompt_question(question)
                answers[question.id] = answer
        else:
            # Non-interactive mode - use defaults
            for question in template.questions:
                if question.default is not None:
                    answers[question.id] = question.default
                elif question.required:
                    raise ValueError(f"Required question '{question.id}' has no default value for non-interactive mode")
        
        # Generate files
        files = template.generate(answers)
        
        # Write files to disk
        for file in files:
            file_path = Path(output_path) / file.path
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(file.content, encoding='utf-8')
        
        return files
    
    def _prompt_question(self, question: TemplateQuestion) -> Any:
        """Prompt user for a question answer"""
        from rich.prompt import Prompt, Confirm
        from rich.console import Console
        
        console = Console()
        
        prompt_text = question.question
        if question.help_text:
            prompt_text += f" ({question.help_text})"
        
        if question.type == QuestionType.BOOLEAN:
            return Confirm.ask(prompt_text, default=question.default or False)
        elif question.type == QuestionType.SELECT:
            if question.options:
                return Prompt.ask(prompt_text, choices=question.options, default=question.default)
            else:
                return Prompt.ask(prompt_text, default=question.default)
        elif question.type == QuestionType.MULTISELECT:
            if question.options:
                console.print(f"\n{prompt_text}")
                console.print("Available options:")
                for i, option in enumerate(question.options, 1):
                    console.print(f"  {i}. {option}")
                
                selection = Prompt.ask("Enter numbers separated by commas (e.g., 1,3,5)", default="")
                if not selection:
                    return question.default or []
                
                try:
                    indices = [int(x.strip()) - 1 for x in selection.split(',')]
                    return [question.options[i] for i in indices if 0 <= i < len(question.options)]
                except (ValueError, IndexError):
                    console.print("[red]Invalid selection, using defaults[/]")
                    return question.default or []
            else:
                return Prompt.ask(prompt_text, default=question.default)
        else:  # TEXT, NUMBER
            return Prompt.ask(prompt_text, default=question.default)