"""
User Data Sync Workflow

API integration with Trino database for user data synchronization

Generated by Valiant API + Database Template
"""

from typing import Dict
from valiant import Workflow, step, InputField, workflow
import requests
import trino
import pandas as pd


@workflow("user_data_sync")
class UserDataSyncWorkflow(Workflow):
    """API integration with Trino database for user data synchronization"""
    
    name = "User Data Sync"
    description = "API integration with Trino database for user data synchronization"
    version = "1.0.0"
    tags = ["api", "database", "integration", "trino"]
    
    def inputs(self):
        """Define input fields for the workflow"""
        return [
            InputField("batch_size", type="number", min_value=1, max_value=10000,
                      default=1000, help_text="Records to process per batch"),
            InputField("api_key", type="password", required=True,
                      help_text="API key for authentication"),
        ]

    @step("Fetch API Data", order=1, tags=["api", "fetch"])
    def fetch_api_data(self, context: Dict):
        """Fetch data from the REST API"""
        try:
            headers = self._get_auth_headers(context)
            response = requests.get(
                f"{context['api_base_url']}/users",
                headers=headers,
                timeout=30
            )
            response.raise_for_status()
            
            api_data = response.json()
            context["api_data"] = api_data
            context["api_record_count"] = len(api_data) if isinstance(api_data, list) else 1
            
            result = self.success(f"Fetched {len(api_data) if isinstance(api_data, list) else 1} records from API")
            result.add_metric("api_records_fetched", context["api_record_count"])
            result.add_metric("api_response_time", response.elapsed.total_seconds())
            result.add_tag("api-success")
            
            return result
            
        except requests.exceptions.RequestException as e:
            return self.failure(f"API request failed: {str(e)}")
        except Exception as e:
            return self.failure(f"Unexpected error fetching API data: {str(e)}")

    @step("Validate Data", order=2, tags=["validation"])
    def validate_data(self, context: Dict):
        """Validate the fetched data"""
        try:
            data = context.get("api_data", [])
            if not data:
                return self.failure("No data to validate")
            
            # Convert to DataFrame for validation
            if isinstance(data, list):
                df = pd.DataFrame(data)
            else:
                df = pd.DataFrame([data])
            
            validation_errors = []
            valid_records = 0
            
            # Basic validation checks
            for idx, row in df.iterrows():
                row_errors = []
                
                # Check for required fields (customize based on your data)
                required_fields = ["id"]  # Add your required fields
                for field in required_fields:
                    if field not in row or pd.isna(row[field]):
                        row_errors.append(f"Missing required field: {field}")
                
                if not row_errors:
                    valid_records += 1
                else:
                    validation_errors.extend([f"Row {idx}: {err}" for err in row_errors])
            
            context["validation_errors"] = validation_errors
            context["valid_record_count"] = valid_records
            context["total_record_count"] = len(df)
            
            if validation_errors:
                error_rate = len(validation_errors) / len(df) * 100
                if error_rate > 10:  # More than 10% errors
                    return self.failure(f"Validation failed: {error_rate:.1f}% error rate ({len(validation_errors)} errors)")
            
            result = self.success(f"Validated {valid_records} of {len(df)} records")
            result.add_metric("valid_records", valid_records)
            result.add_metric("validation_errors", len(validation_errors))
            result.add_metric("error_rate_percent", len(validation_errors) / len(df) * 100)
            result.add_tag("validation-complete")
            
            return result
            
        except Exception as e:
            return self.failure(f"Data validation failed: {str(e)}")

    @step("Insert to Database", order=3, tags=["database", "insert"])
    def insert_to_database(self, context: Dict):
        """Insert transformed data into Trino database"""
        try:
            data = context.get("api_data", [])
            if not data:
                return self.failure("No data to insert")
            
            conn = self._get_trino_connection(context)
            cursor = conn.cursor()
            
            inserted_count = 0
            batch_size = context.get("batch_size", 1000)
            
            # Process in batches
            for i in range(0, len(data), batch_size):
                batch = data[i:i + batch_size]
                
                # Generate INSERT statement (customize based on your table schema)
                placeholders = ", ".join(["?" for _ in batch[0].keys()])
                columns = ", ".join(batch[0].keys())
                insert_query = f"INSERT INTO hive.default.users ({columns}) VALUES ({placeholders})"
                
                # Execute batch insert
                for record in batch:
                    cursor.execute(insert_query, list(record.values()))
                    inserted_count += 1
            
            cursor.close()
            conn.close()
            
            context["inserted_count"] = inserted_count
            
            result = self.success(f"Inserted {inserted_count} records into database")
            result.add_metric("records_inserted", inserted_count)
            result.add_metric("batch_size_used", batch_size)
            result.add_tag("database-insert")
            
            return result
            
        except Exception as e:
            return self.failure(f"Database insertion failed: {str(e)}")

    def _get_auth_headers(self, context: Dict) -> Dict[str, str]:
        """Get authentication headers for API requests"""
        api_key = context.get("api_key")
        if not api_key:
            raise ValueError("API key is required for authentication")
        
        return {
            "X-API-Key": api_key,
            "Content-Type": "application/json"
        }

    def _get_trino_connection(self, context: Dict):
        """Get Trino database connection"""
        try:
            conn = trino.dbapi.connect(
                host="localhost:8080",
                port=443,  # Adjust based on your Trino setup
                user="workflow_user",  # Adjust based on your auth setup
                catalog="hive",
                schema="default",
                http_scheme="https"  # Adjust if using HTTP
            )
            return conn
        except Exception as e:
            raise ConnectionError(f"Failed to connect to Trino: {str(e)}")